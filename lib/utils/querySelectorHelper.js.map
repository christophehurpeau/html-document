{"version":3,"sources":["../../src/utils/querySelectorHelper.js"],"names":[],"mappings":";;;;;;;;;;iCAAkC,qBAAqB;;AACvD,IAAM,SAAS,GAAG,0CAAuB,CAAC;AAC1C,SAAS,CAAC,wBAAwB,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;AAC5D,SAAS,CAAC,wBAAwB,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;;;;;;;;;;;;;;;;AAa3C,SAAS,aAAa,CAAC,OAAO,EAAE,KAAK,EAAE;AAC1C,QAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;;AAEnC,QAAM,QAAQ,GAAG,kBAAkB,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AACpD,QAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,EAAE,CAAC;;AAE7B,QAAI,IAAI,IAAI,IAAI,CAAC,KAAK,EAAE;AACpB,eAAO,IAAI,CAAC,KAAK,CAAC;KACrB;;AAED,WAAO,IAAI,CAAC;CACf;;;;;;;;;;;AAQM,SAAS,gBAAgB,CAAC,OAAO,EAAE,KAAK,EAAE;AAC7C,QAAI,KAAK,GAAG,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;;AAEnC,QAAM,MAAM,GAAG,EAAE,CAAC;AAClB,yBAAoB,kBAAkB,CAAC,OAAO,EAAE,KAAK,CAAC,6GAAE;;;;;;;;;;;;YAA/C,QAAO;;AACZ,cAAM,CAAC,IAAI,CAAC,QAAO,CAAC,CAAC;KACxB;;AAED,WAAO,MAAM,CAAC;CACjB;;;;;;;;;;;;AASD,UAAU,cAAc,CAAC,OAAO,EAAE,KAAK,EAAE;AACrC,0BAAkB,OAAO,CAAC,QAAQ,oHAAE;;;;;;;;;;;;YAA3B,KAAK;;AACV,eAAO,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;KACrC;CACJ;;;;;;;;;;;;AASD,UAAU,kBAAkB,CAAC,OAAO,EAAE,KAAK,EAAE;AACzC,0BAAkB,OAAO,CAAC,QAAQ,oHAAE;;;;;;;;;;;;YAA3B,KAAK;;AACV,eAAO,YAAY,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;AAClC,eAAO,kBAAkB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;KAC3C;CACJ;;;;;;;;;;AAOD,SAAS,YAAY,CAAC,OAAO,EAAE,KAAK,EAAE;AAClC,QAAI,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;AAC5B,eAAO,gBAAgB,CAAC,OAAO,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC;KACrD,MAAM,IAAI,KAAK,CAAC,IAAI,KAAK,SAAS,EAAE;AACjC,eAAO,WAAW,CAAC,OAAO,EAAE,KAAK,CAAC,IAAI,CAAC,CAAC;KAC3C;CACJ;;;;;;;;;;AAOD,SAAS,WAAW,CAAC,OAAO,EAAE,IAAI,EAAE;AAChC,WAAO,gBAAgB,CAAC,OAAO,EAAE,CAAC,EAAE,IAAI,EAAJ,IAAI,EAAE,CAAC,CAAC,CAAC;CAChD;;;;;;;;;;AAOD,UAAU,gBAAgB,CAAC,OAAO,EAAE,SAAS,EAAE;AAC3C,0BAAqB,SAAS,oHAAE;;;;;;;;;;;;YAAvB,QAAQ;;AACb,YAAM,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;;AAE3B,YAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,CAAC,EAAE;AAC3B,qBAAS;SACZ;;AAED,YAAI,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,EAAE;AAC9B,kBAAM,OAAO,CAAC;AACd,mBAAO;SACV;;AAED,gBAAQ,IAAI,CAAC,IAAI,CAAC,eAAe;AAC7B,iBAAK,GAAG;AACJ,oBAAM,kBAAkB,GAAG,OAAO,CAAC,kBAAkB,CAAC;AACtD,oBAAI,kBAAkB,IAAI,SAAS,CAAC,kBAAkB,EAAE,IAAI,CAAC,IAAI,CAAC,EAAE;AAChE,0BAAM,kBAAkB,CAAC;iBAC5B;;AAED,sBAAM;AAAA,AACV,iBAAK,GAAG;AACJ,uBAAO,cAAc,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;AAChF,sBAAM;AAAA,AACV,iBAAK,GAAG;AACJ,uBAAO,cAAc,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;AACrE,sBAAM;AAAA,AACV;AACI,uBAAO,kBAAkB,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,CAAC;AAAA,SAChF;;AAED,eAAO;KACV;CACJ;;;;gBAED,SAAS,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE;AAC9B,QAAI,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,IAAI,OAAO,CAAC,OAAO,KAAK,IAAI,CAAC,OAAO,EAAE;AACpE,eAAO,KAAK,CAAC;KAChB;;AAED,QAAI,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE,EAAE;AACrE,eAAO,KAAK,CAAC;KAChB;;AAED,QAAI,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,EAAE;AACnC,YAAI,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,UAAA,IAAI;mBAAI,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC;SAAA,CAAC,EAAE;AAClE,mBAAO,KAAK,CAAC;SAChB;KACJ;;AAED,QAAI,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;AAC9B,YAAI,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAA,IAAI,EAAI;AACzB,gBAAI,CAAC,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;AAClC,uBAAO,KAAK,CAAC;aAChB,MAAM,IAAI,IAAI,CAAC,QAAQ,KAAK,SAAS,EAAE;AACpC,uBAAO,IAAI,CAAC;aACf;;AAED,gBAAI,KAAK,GAAG,OAAO,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;;AAE5C,oBAAQ,IAAI,CAAC,QAAQ;AACjB,qBAAK,GAAG;AACJ,2BAAO,KAAK,KAAK,IAAI,CAAC,KAAK,CAAC;AAAA,AAChC,qBAAK,IAAI;AACL,2BAAO,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAAA,AACxC,qBAAK,IAAI;AACL,2BAAO,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;AAAA,AACtC,qBAAK,IAAI;AACL,wBAAI,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC7B,2BAAO,KAAK,CAAC,IAAI,CAAC,UAAA,IAAI;+BAAI,IAAI,KAAK,IAAI,CAAC,KAAK;qBAAA,CAAC,CAAC;AAAA,AACnD,qBAAK,IAAI;AACL,2BAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;AAAA,AAC5C,qBAAK,IAAI;AACL,2BAAO,KAAK,KAAK,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK,GAAG,GAAG,CAAC,CAAC;AAAA,AACtE;AACI,0BAAM,IAAI,KAAK,CAAC,iCAAiC,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC;AAAA,aAC1E;SACJ,CAAC,EAAE;AACA,mBAAO,KAAK,CAAC;SAChB;KACJ;;AAED,WAAO,IAAI,CAAC;CACf","file":"querySelectorHelper.js","sourcesContent":["import { CssSelectorParser } from 'css-selector-parser';\nconst cssParser = new CssSelectorParser();\ncssParser.registerAttrEqualityMods('^', '$', '*', '~', '|');\ncssParser.registerNestingOperators('>', '+', '~');\n\n/**\n * querySelectorHelper interface provides simple processing\n * of Element.querySelector method.\n */\n\n/**\n *\n * @param {Element} element\n * @param {string} query\n * @return {Element|null}\n */\nexport function querySelector(element, query) {\n    let rules = cssParser.parse(query);\n\n    const iterator = processElementDeep(element, rules);\n    const next = iterator.next();\n\n    if (next && next.value) {\n        return next.value;\n    }\n\n    return null;\n}\n\n/**\n  *\n  * @param {Element} element\n  * @param {string} query\n  * @return {Element[]}\n  */\nexport function querySelectorAll(element, query) {\n    let rules = cssParser.parse(query);\n\n    const result = [];\n    for (let element of processElementDeep(element, rules)) {\n        result.push(element);\n    }\n\n    return result;\n}\n\n/**\n * Function processes one element using current rule\n *\n * @param {HTMLElement} element - element to check\n * @param {*} rules - current rules to check against element\n * @return {boolean}\n */\nfunction* processElement(element, rules) {\n    for (let child of element.children) {\n        yield* processRules(child, rules);\n    }\n}\n\n/**\n * Function processes one element using current rule\n *\n * @param {HTMLElement} element - element to check\n * @param {*} rules - current rules to check against element\n * @return {boolean}\n */\nfunction* processElementDeep(element, rules) {\n    for (let child of element.children) {\n        yield* processRules(child, rules);\n        yield* processElementDeep(child, rules);\n    }\n}\n\n/**\n * @param {Element} element\n * @param {Object} rules\n * @return {boolean}\n */\nfunction processRules(element, rules) {\n    if (rules.type === 'selectors') {\n        return processSelectors(element, rules.selectors);\n    } else if (rules.type === 'ruleSet') {\n        return processRule(element, rules.rule);\n    }\n}\n\n/**\n * @param {Element} element\n * @param {Object} rule\n * @return {boolean}\n */\nfunction processRule(element, rule) {\n    return processSelectors(element, [{ rule }]);\n}\n\n/**\n * @param {Element} element\n * @param {Object[]} selectors\n * @return {boolean}\n */\nfunction* processSelectors(element, selectors) {\n    for (let selector of selectors) {\n        const rule = selector.rule;\n\n        if (!matchRule(element, rule)) {\n            continue;\n        }\n\n        if (!rule.hasOwnProperty('rule')) {\n            yield element;\n            return;\n        }\n\n        switch (rule.rule.nestingOperator) {\n            case '+':\n                const nextElementSibling = element.nextElementSibling;\n                if (nextElementSibling && matchRule(nextElementSibling, rule.rule)) {\n                    yield nextElementSibling;\n                }\n\n                break;\n            case '~':\n                yield* processElement(element.parentNode, { type: 'ruleSet', rule: rule.rule });\n                break;\n            case '>':\n                yield* processElement(element, { type: 'ruleSet', rule: rule.rule });\n                break;\n            default:\n                yield* processElementDeep(element, { type: 'ruleSet', rule: rule.rule });\n        }\n\n        return;\n    }\n}\n\nfunction matchRule(element, rule) {\n    if (rule.hasOwnProperty('tagName') && element.tagName !== rule.tagName) {\n        return false;\n    }\n\n    if (rule.hasOwnProperty('id') && element.getAttribute('id') !== rule.id) {\n        return false;\n    }\n\n    if (rule.hasOwnProperty('classNames')) {\n        if (!rule.classNames.every(name => element.classList.contains(name))) {\n            return false;\n        }\n    }\n\n    if (rule.hasOwnProperty('attrs')) {\n        if (!rule.attrs.some(attr => {\n            if (!element.hasAttribute(attr.name)) {\n                return false;\n            } else if (attr.operator === undefined) {\n                return true;\n            }\n\n            let value = element.getAttribute(attr.name);\n\n            switch (attr.operator) {\n                case '=':\n                    return value === attr.value;\n                case '^=':\n                    return value.startsWith(attr.value);\n                case '$=':\n                    return value.endsWith(attr.value);\n                case '~=':\n                    let words = value.split(' ');\n                    return words.some(word => word === attr.value);\n                case '*=':\n                    return value.indexOf(attr.value) !== -1;\n                case '|=':\n                    return value === attr.value || value.startsWith(attr.value + '-');\n                default:\n                    throw new Error('Unsupported attribute operator ' + attr.operator);\n            }\n        })) {\n            return false;\n        }\n    }\n\n    return true;\n}\n"]}